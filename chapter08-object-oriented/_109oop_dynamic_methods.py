# python用装饰器来区分各个方法：

# python中方法分为
# <1>普通实例方法
# <2>类方法:(@classmethod)
# <3>静态方法:(@staticmethod)



# 其中除了定义为@staticmethod的静态方法，python的其余方法都是动态的，可以灵活的为类添加其它的方法。

# 前面提到过：python可以自由地，在"类"中增加属性，
# 当把自己定义的函数(不是方法)，通过在代码的实际运行过程中，
# 为添加属性并将属性(以赋值的=形式)绑定一个自定义函数，如:

# Person.Play=PlayGame,这条语句就是《在类中增加一个新的类对象的属性Play》的同时《将这个属性重新绑定一个自定义函数PlayGame(self)》


'''
注:这种自定义函数写出来有很强的目的性，就是预备、就绪着、将要传到某个类内部而编写的，其格式具有显著特点:
由于在类内使用它必须设置第一个self参数,这样确保能放置到类后能够被获取到类的实例对象。

那么设置了self参数的它.也难以直接作为自定义函数直接使用,只能放在"类"里面才能生效了,可见,"self"作为它的标志,目的性明确。

因此除了类内,一旦看见(self)参数的函数,证明它早晚也要利用类的动态特性,传递到类内,为类提高更灵活的代码结构。
'''

# 这样，Student类的内部就在代码的(执行过程中，而不是编译前)载入了新的方法：Play，具有灵活性。
# p=Student() 
# p.Play()就可以调用了。

class Student:
    pass

def PlayGames(self):
    print("向Student类内在代码执行中执行到Student.Play=PlayGames时载入了这个自定义函数")

Student.Play=PlayGames

p=Student()
p.Play()