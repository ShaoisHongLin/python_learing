
'''
1.生成器(generate expression)对象，它与推导式生成(comprehension)做出区分。


生成器对象可以转化成生成器对象，并用来"迭代遍历"（输出），仅一次,之后就会变成空对象
'''
a=(x*2 for x in range(4))
print(type(a))
'''
class--<generator >
'''

b=tuple(a)
print(b)   # (0,2,4,6)第一次以generator本质，转化来的tuple对象可以遍历一次。

c=tuple(a)
print(c)   # 第二次：再度遍历整个tuple的操作，发现：是空对象。终究用generator转化来的tuple不是真正的tuple对象。


'''
思考。为什么要设计一个是推导式生成comprehension，能够遍历多次。还要设计一个是generate expression生成器表达式,遍历一次就从内存中消失呢？

答：comprehension推导式生成，是将数据真实写在内存里，为了保存和多次长期使用这些数据。
而generate expression的"生成器表达式"，它"没有"将数据写在内存中，而是将那些数据暂时提供了一种用指针访问的方式，因此它不占用内存，比如超多超多的数据需要进行一次统一的筛查处理操作，我们不能把它们以推导式生成，塞>进真实的内存里，多半会造成不必要的大量内存损耗，我们用生成器表达式的方式，用一次性的指针访问它们进行一次性的某些操作，这样就不用为海量数据分配内存，而且还能进行简单的操作。

'''


'''
2.用__next__()移动指针，这样不必转化为形式上的tuple，直接通过指针使用生成器。
'''
e=(x*3 for x in range(3))
print(e.__next__())
print(e.__next__())
print(e.__next__())
# print(e.__next__())  这行会报错，因为指针已经到达结尾。 Stop Iteration


'''
问：为什么生成器对象不论是转化成tuple还是直接用生成器的__next__()遍历只能遍历一次？
因为：生成器对象有一个指针，放在最开头，如果对这个生成器对象施加操作，它会利用指针移动，直到最末尾。
当再次访问，它无法自己移动到最开头。
'''

