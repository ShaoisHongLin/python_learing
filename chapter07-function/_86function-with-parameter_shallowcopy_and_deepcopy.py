# 上一节讲了比较重要的知识：参数传递方式-----《共享传递》，讲述了"实际传入的参数"和"函数体内的逻辑中的参数(形参在逻辑处理中的部分)",二者《共享》同一个对象的地址。



#  本节将讲解一下相关的"浅拷贝"和"深拷贝"的概念，在各个高级语言里都涉及深浅拷贝的知识，了解参数传递知识的基础上，"深浅拷贝"可以进一步为特定代码实现更好的封装性。

#  1.上节哪里涉及浅拷贝和深拷贝了，记得只提到了共享传递，提到了可变和不可变类型的不同处理。没提到深浅拷贝啊？
'''
#  答：
        1.深拷贝和浅拷贝，
        它们是在"共享传递"的"可变类型"的处理中作为应用场景，
        程序员在此处，添加额外的逻辑处理部分----------"深、浅拷贝"。

        至于程序员为什么要额外增加"深拷贝或浅拷贝"的逻辑处理部分，在函数体内做一步额外的处理呢？

        
        2.通俗来讲："深、浅拷贝"是为了用于增强数据的封装性，避免对外界原始数据产生影响，下面解释原因：

        上节课中，了解到：
        可变类型,如list、dict的默认处理过程中,并没有"创建出(拷贝出)一个新的对象",而是直接影响了原本的参数对象，或者说"影响了函数外部的内容，影响了原始数据"。

        但是程序员如果想让函数体的内容阻止它对"函数封装部分以外的list和dict"造成修改,保证修改只发生在函数体内部,就要学习《共享传递--不可变类型》"的处理方式，
        即"以创建一个新对象的方式来处理它们",而这就是拷贝的概念:-----"创建一个在《相同》的对象",新旧对象的拷贝的《相同程度》则分为'浅和深'，
        故叫做'浅拷贝shallow copy和深拷贝deep copy,下面有对深浅拷贝的具体讲解。
'''
# 2.如果忘了，先回顾上节共享传递的知识

'''    回顾上节:并把重点放在下面内容提到的《未产生新的对象,直接影响了函数外的可变对象》

            如list、dict,就算是不写return,函数执行时回也会对其造成影响:
            "函数体内的处理逻辑的它”和“实际传进来之前的参数”,它们在共享着同一个地址，
             在修改时,《并未产生新的对象,直接指向同一个对象,直接引用它进行修改》,产生影响。
'''

# 3.讲解深浅拷贝：提高函数的封装性，使得函数体内的语句不影响外部的对象。
'''
        1.浅拷贝：新对象拷贝'子对象'的地址(即第一层基本内容),但不拷贝其后代的结构(即嵌套的list)
                 这种拷贝,在简单的list、dict结构中可以视为"完全相同"的新对象。
                 新对象与旧的'子对象'共享地址,更适合简单的list(不嵌套更多的list的复杂结构),因为每当使用复杂结构的list,由于拷贝的程度较浅,增删list的嵌套内容部分时候,会导致一起共享地址的两个对象被同时修改,
                 造成"函数体外的对象仍被误修改"的缺点。

                 因此叫做"浅"拷贝,适用于无嵌套、且不复杂的list、dict可变类型。
'''
'''
        2.深拷贝：新对象将拷贝完整的"整个后代(所有层次的内容)"的结构以及'地址',就算是在复杂的list、dict结构中,仍可以视为"完全相同"的新对象
                 深拷贝下,对即使复杂的list进行修改,也是二者独立的,不会产生"造成函数体外的对象被误修改"的错误场景。

                 因此叫做"深"拷贝,适用于list内套list那种复杂的可变类型。


                注:显然深拷贝是不错的替代品,但是也有性能代价,能对简单list采用浅拷贝时候尽量采用浅拷贝。                 
'''


# 借助代码体会：
import copy

# 创建一个包含嵄巧列表的列表
original_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 执行浅拷贝
shallow_copied_list = copy.copy(original_list)

# 执行深拷贝
deep_copied_list = copy.deepcopy(original_list)

# 修改原始列表中的一个子列表的元素
original_list[0][0] = 'X'

# 打印所有列表以查看效果
print("Original List:",original_list)
print("Shallow Copied List:可以看到shallow copy在list有嵌套结构时候,会存在缺陷,对孙代内容进行操作时候，导致函数外界的对象被改变",shallow_copied_list)
print("Deep Copied List:可以看到deep copy即使在list有嵌套结构时候也依旧不会误改变对象",deep_copied_list)
